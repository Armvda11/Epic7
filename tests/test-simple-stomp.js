#!/usr/bin/env node

/**
 * Test RTA simplifi√© avec authentification basique
 * Test de connexion WebSocket/STOMP avec gestion d'erreurs am√©lior√©e
 */

const SockJS = require('sockjs-client');
const { Client } = require('@stomp/stompjs');
global.WebSocket = require('ws');

class SimpleStompTest {
    constructor() {
        this.backendUrl = 'http://localhost:8080/ws';
        this.stompClient = null;
        this.testResults = [];
        this.connectionEstablished = false;
        this.messagesReceived = [];
        
        // Configuration des h√©ros selon le seeder exact
        this.herm√°sUserId = 2;
        this.aryaUserId = 3;
        
        this.herm√°sHeroes = [
            { id: 0, name: 'Hwayoung', speed: 147, attack: 1228, defense: 592, health: 6266 },
            { id: 1, name: 'Ml Piera', speed: 160, attack: 1182, defense: 627, health: 5542 }
        ];
        
        this.aryaHeroes = [
            { id: 0, name: 'Hwayoung', speed: 142, attack: 1200, defense: 580, health: 6100 },
            { id: 3, name: 'Krau', speed: 135, attack: 740, defense: 1150, health: 7900 }
        ];
    }

    /**
     * Test de connexion simplifi√©
     */
    async runSimpleConnectionTest() {
        console.log('üöÄ === TEST CONNEXION STOMP SIMPLIFI√â ===');
        console.log(`üì° URL: ${this.backendUrl}`);
        
        try {
            // Test 1: Connexion basique
            await this.testBasicConnection();
            
            // Test 2: Test des corrections RTA (simulation)
            await this.testRtaCorrectionsSimulation();
            
            this.displayResults();
            return { success: true };
            
        } catch (error) {
            console.error('‚ùå Erreur:', error.message);
            this.testResults.push({
                test: 'Simple Connection Test',
                status: '‚ùå ERREUR',
                details: error.message,
                timestamp: new Date().toISOString()
            });
            return { success: false, error: error.message };
        } finally {
            this.cleanup();
        }
    }

    /**
     * Test de connexion basique sans authentification
     */
    async testBasicConnection() {
        return new Promise((resolve, reject) => {
            console.log('üîå Test de connexion basique...');
            
            this.stompClient = new Client({
                webSocketFactory: () => new SockJS(this.backendUrl),
                connectHeaders: {
                    // Pas d'authentification pour ce test basique
                },
                debug: (str) => {
                    console.log('üîç STOMP:', str.substring(0, 100) + (str.length > 100 ? '...' : ''));
                },
                reconnectDelay: 0, // Pas de reconnexion automatique
                heartbeatIncoming: 0,
                heartbeatOutgoing: 0,
            });

            let resolved = false;

            this.stompClient.onConnect = (frame) => {
                if (!resolved) {
                    resolved = true;
                    console.log('‚úÖ Connexion STOMP r√©ussie');
                    this.connectionEstablished = true;
                    
                    this.testResults.push({
                        test: 'Basic STOMP Connection',
                        status: '‚úÖ SUCC√àS',
                        details: 'Connexion √©tablie sans authentification',
                        timestamp: new Date().toISOString()
                    });
                    
                    resolve();
                }
            };

            this.stompClient.onStompError = (frame) => {
                if (!resolved) {
                    resolved = true;
                    const error = `STOMP Error: ${frame.headers['message'] || 'Unknown'} - ${frame.body || ''}`;
                    console.error('‚ùå', error);
                    
                    this.testResults.push({
                        test: 'Basic STOMP Connection',
                        status: '‚ùå √âCHEC',
                        details: error,
                        timestamp: new Date().toISOString()
                    });
                    
                    reject(new Error(error));
                }
            };

            this.stompClient.onWebSocketError = (error) => {
                if (!resolved) {
                    resolved = true;
                    console.error('‚ùå WebSocket Error:', error.message);
                    
                    this.testResults.push({
                        test: 'Basic STOMP Connection',
                        status: '‚ùå √âCHEC',
                        details: `WebSocket Error: ${error.message}`,
                        timestamp: new Date().toISOString()
                    });
                    
                    reject(error);
                }
            };

            this.stompClient.onWebSocketClose = (event) => {
                console.log(`üîå WebSocket ferm√©: Code ${event.code}, Raison: ${event.reason}`);
            };

            try {
                this.stompClient.activate();
            } catch (error) {
                if (!resolved) {
                    resolved = true;
                    reject(error);
                }
            }
            
            // Timeout de s√©curit√©
            setTimeout(() => {
                if (!resolved) {
                    resolved = true;
                    reject(new Error('Timeout de connexion (8s)'));
                }
            }, 8000);
        });
    }

    /**
     * Test des corrections RTA par simulation
     */
    async testRtaCorrectionsSimulation() {
        console.log('‚öîÔ∏è Test des corrections RTA par simulation...');
        
        // Test Correction 1: Index de tour automatique
        this.testTurnIndexCorrection();
        
        // Test Correction 2: Attribution userId
        this.testUserIdAttribution();
        
        // Test Correction 3: Ordre bas√© sur vitesse
        this.testSpeedBasedOrder();
    }

    /**
     * Test Correction 1: Index de tour automatique
     */
    testTurnIndexCorrection() {
        console.log('üîß Test correction index de tour...');
        
        const battleState = {
            currentTurnIndex: -1, // Index invalide
            turnOrder: this.calculateTurnOrder(),
            players: [
                { userId: this.herm√°sUserId, heroes: this.herm√°sHeroes },
                { userId: this.aryaUserId, heroes: this.aryaHeroes }
            ]
        };
        
        // Simulation de la correction
        const correctedIndex = this.correctTurnIndex(battleState);
        const success = correctedIndex === 0;
        
        this.testResults.push({
            test: 'Turn Index Correction',
            status: success ? '‚úÖ SUCC√àS' : '‚ùå √âCHEC',
            details: `Index ${battleState.currentTurnIndex} ‚Üí ${correctedIndex}`,
            timestamp: new Date().toISOString()
        });
        
        console.log(`üîß Index corrig√©: ${battleState.currentTurnIndex} ‚Üí ${correctedIndex}`);
    }

    /**
     * Test Correction 2: Attribution userId
     */
    testUserIdAttribution() {
        console.log('üë§ Test attribution userId...');
        
        const action = {
            actionType: 'ATTACK',
            sourceHeroId: 1, // Ml Piera (appartient √† hermas)
            targetHeroId: 0, // Hwayoung (appartient √† arya)
            userId: null // √Ä d√©terminer automatiquement
        };
        
        // Simulation de l'attribution
        const attributedUserId = this.attributeUserId(action);
        const success = attributedUserId === this.herm√°sUserId;
        
        this.testResults.push({
            test: 'UserId Attribution',
            status: success ? '‚úÖ SUCC√àS' : '‚ùå √âCHEC',
            details: `UserId attribu√©: ${attributedUserId} (attendu: ${this.herm√°sUserId})`,
            timestamp: new Date().toISOString()
        });
        
        console.log(`üë§ UserId attribu√©: ${attributedUserId}`);
    }

    /**
     * Test Correction 3: Ordre bas√© sur vitesse
     */
    testSpeedBasedOrder() {
        console.log('‚ö° Test ordre bas√© sur vitesse...');
        
        const allHeroes = [
            { ...this.herm√°sHeroes[0], userId: this.herm√°sUserId }, // Hwayoung 147
            { ...this.herm√°sHeroes[1], userId: this.herm√°sUserId }, // Ml Piera 160
            { ...this.aryaHeroes[0], userId: this.aryaUserId },     // Hwayoung 142
            { ...this.aryaHeroes[1], userId: this.aryaUserId }      // Krau 135
        ];
        
        const turnOrder = this.calculateTurnOrder(allHeroes);
        
        // V√©rifier l'ordre correct: Ml Piera(160) ‚Üí Hwayoung hermas(147) ‚Üí Hwayoung arya(142) ‚Üí Krau(135)
        const expectedOrder = ['Ml Piera', 'Hwayoung', 'Hwayoung', 'Krau'];
        const actualOrder = turnOrder.map(h => h.name);
        
        const orderCorrect = JSON.stringify(expectedOrder) === JSON.stringify(actualOrder);
        
        this.testResults.push({
            test: 'Speed-Based Turn Order',
            status: orderCorrect ? '‚úÖ SUCC√àS' : '‚ùå √âCHEC',
            details: `Ordre: ${turnOrder.map(h => `${h.name}(${h.speed})`).join(' ‚Üí ')}`,
            timestamp: new Date().toISOString()
        });
        
        console.log(`‚ö° Ordre calcul√©: ${turnOrder.map(h => `${h.name}(${h.speed})`).join(' ‚Üí ')}`);
    }

    /**
     * Correction d'index de tour invalide
     */
    correctTurnIndex(battleState) {
        if (battleState.currentTurnIndex < 0 || 
            battleState.currentTurnIndex >= battleState.turnOrder.length) {
            return 0; // Corriger √† 0
        }
        return battleState.currentTurnIndex;
    }

    /**
     * Attribution automatique d'userId bas√©e sur le h√©ros source
     */
    attributeUserId(action) {
        // Logique bas√©e sur la possession des h√©ros selon le seeder
        const herm√°sHeroIds = this.herm√°sHeroes.map(h => h.id);
        const aryaHeroIds = this.aryaHeroes.map(h => h.id);
        
        if (herm√°sHeroIds.includes(action.sourceHeroId)) {
            return this.herm√°sUserId;
        } else if (aryaHeroIds.includes(action.sourceHeroId)) {
            return this.aryaUserId;
        }
        
        // Par d√©faut, attribuer au premier joueur
        return this.herm√°sUserId;
    }

    /**
     * Calcul de l'ordre des tours bas√© sur la vitesse
     */
    calculateTurnOrder(heroes = null) {
        if (!heroes) {
            heroes = [
                { ...this.herm√°sHeroes[0], userId: this.herm√°sUserId },
                { ...this.herm√°sHeroes[1], userId: this.herm√°sUserId },
                { ...this.aryaHeroes[0], userId: this.aryaUserId },
                { ...this.aryaHeroes[1], userId: this.aryaUserId }
            ];
        }
        
        return heroes.sort((a, b) => b.speed - a.speed);
    }

    /**
     * Affichage des r√©sultats
     */
    displayResults() {
        console.log('\nüèÅ === R√âSULTATS DES TESTS ===');
        console.log(`üìä Tests ex√©cut√©s: ${this.testResults.length}`);
        
        this.testResults.forEach((result, index) => {
            console.log(`\n${index + 1}. ${result.test}`);
            console.log(`   Status: ${result.status}`);
            console.log(`   D√©tails: ${result.details}`);
        });
        
        const successCount = this.testResults.filter(r => r.status.includes('SUCC√àS')).length;
        const failureCount = this.testResults.length - successCount;
        
        console.log(`\nüìà Bilan: ${successCount} succ√®s, ${failureCount} √©checs`);
        
        if (this.messagesReceived.length > 0) {
            console.log(`\nüì® Messages re√ßus: ${this.messagesReceived.length}`);
        }
    }

    /**
     * Nettoyage
     */
    cleanup() {
        console.log('üßπ Nettoyage...');
        
        if (this.stompClient && this.stompClient.active) {
            this.stompClient.deactivate();
        }
    }
}

// Ex√©cution
if (require.main === module) {
    const test = new SimpleStompTest();
    test.runSimpleConnectionTest()
        .then(result => {
            console.log(`\nüéØ Test ${result.success ? 'R√âUSSI' : '√âCHOU√â'}`);
            process.exit(result.success ? 0 : 1);
        })
        .catch(error => {
            console.error('\nüí• Erreur fatale:', error.message);
            process.exit(1);
        });
}

module.exports = SimpleStompTest;
